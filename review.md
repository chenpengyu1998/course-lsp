进程管理
    kill
        默认发送SIGTERM信号，kill  4096 终止PID为4096的进程
        kill发送SIGKILL可以强制终止进程，此信号不可被捕获
        SIGKILL的数值是9，使用方式：kill  -9  4096
        如果不是root用户，并且进程也不属于当前用户，需要加sudo
        或者切换到root用户

    ps
        显示进程信息，使用ps  -e显示所有进程，或者使用ps  -a
        
    Ctrl+C
        强制中断进程，发送SIGINT信号

    Ctrl+Z
        进程转到后台暂停

    jobs
        显示后台任务列表

    fg
        fg  1把后台任务号为1的进程转到前台执行

    bg
        bg  1让后台任务号为1的进程在后台继续执行

文件与权限
    cp
        复制文件/目录，目录要使用 -R选项：cp  -R  a/ tmp/

    mv
        移动文件/目录，和cp命令不同，mv移动目录不需要-R

    rm
        删除文件/目录，rm可以删除非空目录，
        使用rm删除目录：rm -rf  a/
    
    rmdir
        删除空目录，只能删除空目录

    mkdir
        创建目录，如果要自动创建父级目录，使用-p选项：
            mkdir  -p  a/b/c

    chmod
        设置文件权限，可用一个8进制数字表示权限：
            chmod 754 a
        chmod u+x a 对所属用户添加可执行权限

    chown
        设置文件/目录所属用户，
        设置tmp目录所属用户和用户组为axy，linuxer：
            chown axy:linxer  tmp/
        如果不是root用户，需要加sudo或者切换到root用户。

保存用户基本信息的文件：
    /etc/passwd

保存用户组信息的文件：
    /etc/group

虚拟文件系统目录：
    /proc
 
/**********************SHELL*********************/
目前Linux默认的shell是bash

shell（bash）执行命令的过程：
    shell获取用户输入并解析
    得到命令名称与参数
    
    如果指定了目录位置，则直接去所在目录查找
    是的话则查看文件是否存在以及是否可执行，
    是的话则执行，否则提示错误信息

    如果没有指定目录位置，则查看是否是内建命令
    是的话执行内建命令，
    
    否则开始查找命令，从PATH环境变量设置的路径
    逐个查找，找到则返回并执行，否则提示错误信息

shell常用环境变量：
    HOME    用户主目录，也可以用～表示
    PATH    默认搜索命令的路径
    PWD     当前工作目录

    输出环境变量：echo $HOME，而～不用加$，使用echo ~

声明默认执行脚本的shell：
    #!/bin/bash
    第一行这样写表示默认使用/bin/bash执行此脚本，这在直接运行
    具备可执行权限的文件时起作用

shell设置变量：
    允许数字，字母，下划线，必须是字母或下划线开头，=左右不能有空格
    正确的格式：
        a=123
        a1=123
        a_1=123
    错误的格式：
        2a=123
        a  =  123
/*********************************************/

其他常用命令：
    echo  cat  ls  cd  pwd
    ln ：用于创建符号链接和硬链接

/*******************重定向和管道********************/

重定向原理：
    设计原则：
        最低可用文件描述符原则
        文件描述符：0，1，2表示标准输入，标准输出，标准错误输出

    基于这两个原则，以输出重定向为例，如果程序开始调用close(1);
    关闭文件描述符1关联的设备文件，再打开新的文件，
    会把文件描述符1分配给新打开的文件。
    此时调用标准输出函数输出的数据就会流向到新打开的文件。

在shell中，重定向操作符号：
    >   标准输出重定向
    <   标准输入重定向
    2>  标准错误输出重定向
    >>  标准输出重定向，追加到文件末尾


在shell中可以使用 | 连接一个程序的输出和另一个程序的输入，|被称为管道。
实际上，shell在遇到|会创建管道，
并把前一个命令的输出重定向到管道，
后一个命令的输入重定向到管道。

示例：find /  -iname *wps*  2> /dev/null | wc -l 执行过程
    shell创建管道，并创建两个子进程，
    第一个子进程标准输出重定向到管道，标准错误输出重定向到/dev/null，
    第二个子进程的标准输入重定向到管道。
    第一个子进程运行命令find，第二个子进程运行命令wc。


/*****************************************/




/**************Linux 系统调用***********/
kill
    kill(-1, SIGINT);表示向所有具备权限的进程发送SIGINT信号。

fork
    创建子进程，出错返回-1，
    成功则在父进程返回子进程PID，在子进程返回0
    根据不同返回值可以控制父进程和子进程执行不同的代码
    如何创建指定数量的子进程？

stat，fstat，lstat
    知道调用的功能以及基本使用，
    lstat与stat都是根据路径获取文件状态信息，
    不同之处在于lstat在获取链接文件时，获取的是文件本身而不是目标文件

    fstat是根据文件描述符获取状态信息

wait，waitpid
    等待子进程退出
    waitpid结合信号机制可实现异步操作

signal
    注册信号处理函数
    知道如何编写信号处理的函数：
        void  handle_sig(int sig) {
            //...
        }

    signal(SIGINT, handle_sig);
/************************************/

strlen, strcmp, strncmp, strcat, strncat
    基本的字符串处理函数

IO: open, read, write, close
    基本的IO操作
    程序如何知道自身发生了重定向？

守护进程
    特点：
        脱离shell控制，父进程是INIT（PID=1）/systemd
        往往开机启动，在后台执行
        多数情况会在启动后一直运行下去，比如Web服务器软件
       
    如何实现守护进程？
    

文本处理：
    字符串移位包含问题。

cd，pwd
    内建命令的特点，独立编写的命令运行后是不是可以得到正确结果。


